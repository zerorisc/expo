// Copyright lowRISC contributors.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
{
  name: "spi_device"
  import_testplans: ["hw/dv/tools/dvsim/testplans/csr_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/mem_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/alert_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/intr_test_testplan.hjson",
                     "hw/dv/tools/dvsim/testplans/tl_device_access_types_testplan.hjson"]
  testpoints: [
    {
      name: smoke
      desc: '''
            Use default SRAM fifo setting. Seq:
            - Write a word data to TX memory and update wptr
            - Send a word SPI transfer
            - Read a word data from RX memory and update rptr
            - Compare the data and check no pending data in SRAM FIFO
            - Repeat above steps'''
      milestone: V1
      tests: ["spi_device_smoke"]
    }
    {
      name: base_random_seq
      desc: '''
            Create 3 parallel threads
            - Write random data to TX memory unless fifo is full
            - Send SPI transfer unless TX is empty or RX is full
            - Read RX memory unless RX is empty'''
      milestone: V2
      tests: ["spi_device_txrx"]
    }
    {
      name: fifo_full
      desc: '''
            Increase the chance to have fifo full by following
            - Reduce delay to write TX memory
            - Increase delay to read RX memory'''
      milestone: V2
      tests: ["spi_device_fifo_full"]
    }
    {
      name: fifo_underflow_overflow
      desc: '''
            Override spi_device_txrx_vseq to send SPI transfer without checking TX/RX fifo, note:
            - When TX is underflow, SW shouldn't update wptr if spi isn't idle, otherwise, spi may
              send mis-aligned data
            - When RX is overflow, data will be lost and if SW update rptr, received data may be
              mis-aligned
            - Ensure underflow/overflow is triggered correctly'''
      milestone: V2
      tests: ["spi_device_fifo_underflow_overflow"]
    }
    {
      name: dummy_sck_and_dummy_csb
      desc: '''
            Drive dummy sck without csb or drive dummy csb without sck, and test no impact on the
            design'''
      milestone: V2
      tests: ["spi_device_dummy_item_extra_dly"]
    }
    {
      name: extra_delay_on_spi
      desc: '''
            Add extra delay between spi clock edge or extra delay between 2 words data
            This is to test host pause transfer for a while without turning off csb and then stream
            in data again'''
      milestone: V2
      tests: ["spi_device_dummy_item_extra_dly"]
    }
    {
      name: async_fifo_reset
      desc: '''Reset async fifo when SPI interface is idle
            TODO: fifo may be fetching data from SRAM? What is the actual usage?'''
      milestone: V2
      tests: []
    }
    {
      name: interrupts
      desc: '''
            Test all supported interrupts:
            - tx/rx lvl
            - rx full
            - rx error
            - overflow/underflow'''
      milestone: V2
      tests: ["spi_device_intr"]
    }
    {
      name: abort
      desc: '''
            Fill the TX_FIFO(async), then abort pending jobs

            Verify that bit 4 of the SPI Device status register is asserted

            Verify that TXF control returns to Idle state

            TODO: Need to clarify the behavior in spec'''
      milestone: V2
      tests: []
    }
    {
      name: byte_transfer_on_spi
      desc: '''send spi transfer on byte granularity, and make sure the timer never expires'''
      milestone: V2
      tests: ["spi_device_byte_transfer"]
    }
    {
      name: rx_timeout
      desc: '''
            - Send spi transfer on byte granularity, and timer may expires
            - Only check data in sequence level when timer expires. Monitor and scoreboard don't
              model the timer feature
            - Note: Timeout only for RX'''
      milestone: V2
      tests: []
    }
    {
      name: bit_transfer_on_spi
      desc: '''
            Send spi transfer on bit granularity
            - If TX drives < 7 bits, this byte will be sent in next CSB.
            - If TX drives 7 bits and set CSB to high, this byte won't be sent in next CSB'''
      milestone: V2
      tests: []
    }
    {
      name: extreme_fifo_setting
      desc: '''Set fifo size to 4 bytes(minimum), 2k-4bytes(maximum) and others'''
      milestone: V2
      tests: ["spi_device_extreme_fifo_size"]
    }
    {
      name: mode
      desc: '''
            Configure spi device for passthrough mode
            - Perform passthrough mode transactions, monitor and verify
            - TODO: Requires specification update

            Configure spi device for flash mode
            - Perform flash mode transactions, monitor and verify
            - TODO: Requires specification update

            Configure spi device for TPM mode
            - Check that the return-by-HW register values come from the SW read-writable CSRs
            - Verify that the module latches the CSRs from the SYS_CLK domain into the SPI SCK domain when CSb is asserted
            - Verify that the SW is allowed to modify the return-by-HW registers only when CSb is not active
            '''
      milestone: V2
      tests: []
    }
    {
      name: mem_ecc
      desc: '''
            Backdoor hack memory data to test basic memory ECC behavior limitation:
            - Just cover basic functionality and connectivity
            - Complete verification will be done by PFV'''
      milestone: V2
      tests: []
    }
    {
      name: perf
      desc: '''Run spi_device_fifi_full_vseq with very small delays'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_fifo_read
      desc: '''
            - Set TPM_CFG.TPM_MODE to 0.
            - Set TPM_CFG.EN.
            - Randomise other fields in TPM_CFG.
            - Send TPM read command over the SPI bus with a randomised address.
            - Check TPM_CMD_ADDR.
            - Check TPM_STATUS.cmdaddr_notempty and INTR_STATE.tpm_header_notempty, they should be asserted if hw_reg_dis == 0.
            - If hw_reg_dis == 0, the data is returned to the host via return-by-HW register, else the data is returned via read FIFO.
            - Confirm that the TPM submodule sends WAIT until the read FIFO is available.
            - When available, confirm that the TPM submodule sends START followed by the register value.
            - Compare this value with the expected value.'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_write
      desc: '''
            - Set TPM_CFG.TPM_MODE to 0.
            - Set TPM_CFG.EN.
            - Randomise other fields in TPM_CFG.
            - Send TPM write command with a randomised address.
            - Check TPM_CMD_ADDR.
            - Based on FIFO status, check SPI bus to confirm WAIT or START sent.
            - Check that the TPM submodule accepts write data without the WAIT state if the write FIFO is empty.
            - Otherwise, check WAIT until the write FIFO becomes available (empty).'''
      milestone: V2
      tests: []
    }
    {
      name: tpm_crb_read
      desc: '''
            Set TPM_CFG.TPM_MODE to 1.
            Set TPM_CFG.EN.
            Randomise other fields in TPM_CFG.
            Send TPM read command over the SPI bus with a randomised address.
            Check TPM_STATUS.cmdaddr_notempty, INTR_STATE.tpm_header_notempty.
            Confirm that invalid locality check still runs based on the invalid_locality configuration.
            Confirm that the TPM submodule sends START followed by the register value.
            Compare this value with the expected value.'''
      milestone: V2
      tests: []
    }
    {
      name: partial_txrx
      desc: '''
            - Verify that when timer expires while bytes are still in the
              RXFIFO, the logic writes partial words to SRAM.
            - Confirm read-modify-write operation is triggered to perform the
              partial update.
            - Perform multiple partial TX/RX.'''
      milestone: V2
      tests: []
    }
    {
      name: sck_config
      desc: '''
            - Verify that the SPI clock and phase (CFG.CPOL, CFG.CPHA) behave
              as expected by performing a generic rw transaction with
              combinations of polarity and phase.
            - Verify that in the configuration (CFG.CPOL=1, CFG.CPHA=1), the
              logic isn't able to pop the entry from the TX async FIFO after
              the last bit in the last byte of a transaction.
            - Confirm that if CSB is de-asserted in bit 1 to 6 position, the
              FIFO entry isn't popped and that TX logic will re-send the byte
              in next transaction.
            - Confirm that if CSB is de-asserted in the 7th or 8th bit
              position, the data is dropped and will re-commence with the next
              byte in the next transaction.'''
      milestone: V2
      tests: []
    }
  ]
}
