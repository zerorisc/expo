/* Copyright lowRISC contributors. */
/* Licensed under the Apache License, Version 2.0, see LICENSE for details. */
/* SPDX-License-Identifier: Apache-2.0 */

/**
 * Standalone unit tests for Ed25519 signature generation.
 *
 * Tests included in this file are intended for quick sanity-checks of
 * subroutines; they will not cover all edge cases.
 *
 * This test will exit with the number of failures written to the w0 register;
 * w0=0 means all tests succeeded.
 */

.section .text.start

main:
  /* Prepare all-zero register. */
  bn.xor  w31, w31, w31

  /* Initialize failure counter to 0. */
  bn.mov  w0, w31

  /* Run tests. */
  jal     x1, run_rfc_test1

  ecall

/**
 * Check test 1 from RFC 8032, section 7.1.
 *
 * Generate a signature from the test vector data and check that the result
 * matches the expected signature.
 *
 * @param[in]  w0: test failure counter
 * @param[in]  w31: all-zero
 * @param[in]  dmem[ed25519_hash_k]: precomputed hash k (512 bits
 * @param[in]  dmem[ed25519_hash_r]: precomputed hash r (512 bits)
 * @param[in]  dmem[ed25519_hash_h]: precomputed hash h (lower half only, 256 bits)
 * @param[in]  dmem[test1_expected_sig_R]: expected first half of signature
 * @param[in]  dmem[test1_expected_sig_S]: expected second half of signature
 * @param[in]  dmem[test1_expected_public_key]: expected public key
 * @param[out] w0: updated test failure counter
 *
 * clobbered registers: TODO
 * clobbered flag groups: FG0
 */
run_rfc_test1:
  /* Precompute an incremented failure counter to use if a check fails.
       w1 <= w0 + 1 */
  bn.addi  w1, w0, 1

  /* Run stage 1 of the signing algorithm. */
  jal      x1, ed25519_sign_stage1

  /* Load the signature R value generated by stage 1.
       w2 <= dmem[ed25519_sig_R] */
  li       x3, 2
  la       x2, ed25519_sig_R
  bn.lid   x3, 0(x2)

  /* Load the expected R value.
       w3 <= dmem[test1_expected_sig_R] */
  li       x3, 3
  la       x2, test1_expected_sig_R
  bn.lid   x3, 0(x2)

  /* Check if the computed R matches the expected value.
       FG0.Z <= (w2 == w3) */
  bn.cmp   w2, w3
  bn.sel   w0, w0, w1, Z

  /* Load the public key (A) value generated by stage 1.
       w2 <= dmem[ed25519_public_key] */
  li       x3, 2
  la       x2, ed25519_public_key
  bn.lid   x3, 0(x2)

  /* Load the expected public key.
       w3 <= dmem[test1_expected_public_key] */
  li       x3, 3
  la       x2, test1_expected_public_key
  bn.lid   x3, 0(x2)

  /* Check if the computed public key matches the expected value.
       FG0.Z <= (w2 == w3) */
  bn.cmp   w2, w3
  bn.sel   w0, w0, w1, Z

  /* Run stage 2 of the signing algorithm. */
  jal      x1, ed25519_sign_stage2

  /* Load the signature S value generated by stage 2.
       w2 <= dmem[ed25519_sig_S] */
  li       x3, 2
  la       x2, ed25519_sig_S
  bn.lid   x3, 0(x2)

  /* Load the expected S value.
       w3 <= dmem[test1_expected_sig_S] */
  li       x3, 3
  la       x2, test1_expected_sig_S
  bn.lid   x3, 0(x2)

  /* Check if the computed S matches the expected value.
       FG0.Z <= (w2 == w3) */
  bn.cmp   w2, w3
  bn.sel   w0, w0, w1, Z

  ret


.data

/**
 * Data from RFC 8032, Section 7.1, Test 1. From the RFC:
 *   -----TEST 1
 *
 *   ALGORITHM:
 *   Ed25519
 *
 *   SECRET KEY:
 *   9d61b19deffd5a60ba844af492ec2cc4
 *   4449c5697b326919703bac031cae7f60
 *
 *   PUBLIC KEY:
 *   d75a980182b10ab7d54bfed3c964073a
 *   0ee172f3daa62325af021a68f707511a
 *
 *   MESSAGE (length 0 bytes):
 *
 *   SIGNATURE:
 *   e5564300c360ac729086e2cc806e828a
 *   84877f1eb8e5d974d873e06522490155
 *   5fb8821590a33bacc61e39701cf9b46b
 *   d25bf5f0595bbe24655141438e7a100b
 *
 * The sign operation is split into two stages, so we need to compute the input
 * and expected output for both. The stages expect the following input and output:
 *   stage 1 input:
 *     - h = SHA2-512(secret_key) (denote second half of h as "prefix")
 *     - r = SHA2-512(dom2(F, C) || prefix || PH(M))
 *   stage 1 output:
 *     - R_, encoded point, first half of signature
 *     - A_, encoded point, public key
 *   stage 2 input:
 *     - k = SHA2-512(dom2(F, C) || R_ || A_ || PH(M))
 *   stage 2 output:
 *     - S, scalar, second half of signature
 *
 * In this test, dom2(F,C) is the empty string (because we're using Ed25519,
 * not Ed25519ph or Ed25519ctx: see RFC 8032, section 5.1), PH is the identity
 * function, and M is empty, so in fact r = SHA2-512(prefix) and k = SHA-512(R_
 * || A_).
 *
 * Python precomputation transcript for reference (the SHA-512 output is
 * big-endian, so it's reversed in the final data):
 *
 * >>> R_ = bytearray.fromhex('e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e06522490155')
 * >>> A_ = bytearray.fromhex('d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a')
 * >>> secret_key = bytearray.fromhex('9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60')
 * >>> h = SHA512.new(secret_key)
 * >>> (h.digest()[:32]).hex()
 * '357c83864f2833cb427a2ef1c00a013cfdff2768d980c0a3a520f006904de90f'
 * >>> prefix = h.digest()[32:]
 * >>> r = SHA512.new(prefix)
 * >>> r.hexdigest()
 * 'b6b19cd8e0426f5983fa112d89a143aa97dab8bc5deb8d5b6253c928b65272f4044098c2a990039cde5b6a4818df0bfb6e40dc5dee54248032962323e701352d'
 * >>> k = SHA512.new(R_ + A_)
 * >>> k.hexdigest()
 * '2771062b6b536fe7ffbdda0320c3827b035df10d284df3f08222f04dbca7a4c20ef15bdc988a22c7207411377c33f2ac09b1e86a046234283768ee7ba03c0e9f'
 */
.globl ed25519_hash_k
.balign 32
ed25519_hash_k:
  .word 0x2b067127
  .word 0xe76f536b
  .word 0x03dabdff
  .word 0x7b82c320
  .word 0x0df15d03
  .word 0xf0f34d28
  .word 0x4df02282
  .word 0xc2a4a7bc
  .word 0xdc5bf10e
  .word 0xc7228a98
  .word 0x37117420
  .word 0xacf2337c
  .word 0x6ae8b109
  .word 0x28346204
  .word 0x7bee6837
  .word 0x9f0e3ca0

.globl ed25519_hash_r
.balign 32
ed25519_hash_r:
  .word 0xd89cb1b6
  .word 0x596f42e0
  .word 0x2d11fa83
  .word 0xaa43a189
  .word 0xbcb8da97
  .word 0x5b8deb5d
  .word 0x28c95362
  .word 0xf47252b6
  .word 0xc2984004
  .word 0x9c0390a9
  .word 0x486a5bde
  .word 0xfb0bdf18
  .word 0x5ddc406e
  .word 0x802454ee
  .word 0x23239632
  .word 0x2d3501e7

.globl ed25519_hash_h_low
.balign 32
ed25519_hash_h_low:
  .word 0x86837c35
  .word 0xcb33284f
  .word 0xf12e7a42
  .word 0x3c010ac0
  .word 0x6827fffd
  .word 0xa3c080d9
  .word 0x06f020a5
  .word 0x0fe94d90
  .word 0x86837c35
  .word 0xcb33284f
  .word 0xf12e7a42
  .word 0x3c010ac0
  .word 0x6827fffd
  .word 0xa3c080d9
  .word 0x06f020a5
  .word 0x0fe94d90

.globl test1_expected_sig_R
.balign 32
test1_expected_sig_R:
  .word 0x004356e5
  .word 0x72ac60c3
  .word 0xcce28690
  .word 0x8a826e80
  .word 0x1e7f8784
  .word 0x74d9e5b8
  .word 0x65e073d8
  .word 0x55014922

.globl test1_expected_sig_S
.balign 32
test1_expected_sig_S:
  .word 0x1582b85f
  .word 0xac3ba390
  .word 0x70391ec6
  .word 0x6bb4f91c
  .word 0xf0f55bd2
  .word 0x24be5b59
  .word 0x43415165
  .word 0x0b107a8e

.globl test1_expected_public_key
.balign 32
test1_expected_public_key:
  .word 0x01985ad7
  .word 0xb70ab182
  .word 0xd3fe4bd5
  .word 0x3a0764c9
  .word 0xf372e10e
  .word 0x2523a6da
  .word 0x681a02af
  .word 0x1a5107f7
